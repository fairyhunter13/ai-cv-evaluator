name: Secrets Healthcheck

on:
  workflow_dispatch:
  schedule:
    - cron: "0 1 * * *" # 01:00 UTC daily

jobs:
  healthcheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # ============================================================
      # AI Provider API Keys
      # ============================================================
      - name: Groq account 1 - models endpoint
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        run: |
          if [ -z "${GROQ_API_KEY}" ]; then
            echo "GROQ_API_KEY not set; skipping Groq account 1 healthcheck"
            exit 0
          fi
          set -euo pipefail
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${GROQ_API_KEY}" \
            https://api.groq.com/openai/v1/models)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Groq account 1 /models status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "Groq account 1 healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ Groq account 1 API key is valid"

      - name: Groq account 2 - models endpoint
        env:
          GROQ_API_KEY_2: ${{ secrets.GROQ_API_KEY_2 }}
        run: |
          if [ -z "${GROQ_API_KEY_2}" ]; then
            echo "GROQ_API_KEY_2 not set; skipping Groq account 2 healthcheck"
            exit 0
          fi
          set -euo pipefail
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${GROQ_API_KEY_2}" \
            https://api.groq.com/openai/v1/models)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Groq account 2 /models status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "Groq account 2 healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ Groq account 2 API key is valid"

      - name: OpenRouter account 1 - auth/key endpoint
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          if [ -z "${OPENROUTER_API_KEY}" ]; then
            echo "OPENROUTER_API_KEY not set; skipping OpenRouter account 1 healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Use /api/v1/auth/key to validate the key itself (requires auth)
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${OPENROUTER_API_KEY}" \
            https://openrouter.ai/api/v1/auth/key)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "OpenRouter account 1 /auth/key status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "OpenRouter account 1 healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ OpenRouter account 1 API key is valid"

      - name: OpenRouter account 2 - auth/key endpoint
        env:
          OPENROUTER_API_KEY_2: ${{ secrets.OPENROUTER_API_KEY_2 }}
        run: |
          if [ -z "${OPENROUTER_API_KEY_2}" ]; then
            echo "OPENROUTER_API_KEY_2 not set; skipping OpenRouter account 2 healthcheck"
            exit 0
          fi
          set -euo pipefail
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${OPENROUTER_API_KEY_2}" \
            https://openrouter.ai/api/v1/auth/key)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "OpenRouter account 2 /auth/key status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "OpenRouter account 2 healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ OpenRouter account 2 API key is valid"

      - name: OpenAI - models endpoint
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          if [ -z "${OPENAI_API_KEY}" ]; then
            echo "OPENAI_API_KEY not set; skipping OpenAI healthcheck"
            exit 0
          fi
          set -euo pipefail
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            https://api.openai.com/v1/models)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "OpenAI /models status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "OpenAI healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ OpenAI API key is valid"

      # ============================================================
      # Infrastructure & DevOps Secrets
      # ============================================================

      - name: Cloudflare - token verify endpoint
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          if [ -z "${CLOUDFLARE_API_TOKEN}" ]; then
            echo "CLOUDFLARE_API_TOKEN not set; skipping Cloudflare healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Use the official token verify endpoint
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            https://api.cloudflare.com/client/v4/user/tokens/verify)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Cloudflare token verify status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "Cloudflare healthcheck failed with status ${status}" >&2
            exit 1
          fi
          # Check if token status is active
          token_status=$(echo "$body" | jq -r '.result.status // empty')
          if [ "${token_status}" != "active" ]; then
            echo "Cloudflare token is not active: ${token_status}" >&2
            exit 1
          fi
          echo "✓ Cloudflare API token is valid and active"

      - name: Cloudflare - zone access verification
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          if [ -z "${CLOUDFLARE_API_TOKEN}" ] || [ -z "${CLOUDFLARE_ZONE_ID}" ]; then
            echo "Cloudflare zone secrets not fully set; skipping zone access check"
            exit 0
          fi
          set -euo pipefail
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}")
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Cloudflare zone access status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "Cloudflare zone access check failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ Cloudflare zone access verified"

      # ============================================================
      # Security & Compliance Tools
      # ============================================================
      - name: Snyk - REST API self endpoint
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          if [ -z "${SNYK_TOKEN}" ]; then
            echo "SNYK_TOKEN not set; skipping Snyk healthcheck"
            exit 0
          fi
          set -euo pipefail
          # REST API requires Content-Type header
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: token ${SNYK_TOKEN}" \
            -H "Content-Type: application/vnd.api+json" \
            "https://api.snyk.io/rest/self?version=2024-10-15")
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Snyk REST /self status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "Snyk healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ Snyk API token is valid"

      - name: Semgrep - token format validation
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
        run: |
          if [ -z "${SEMGREP_APP_TOKEN}" ]; then
            echo "SEMGREP_APP_TOKEN not set; skipping Semgrep healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Semgrep tokens are typically long alphanumeric strings
          # Format check: should be non-empty and look like a valid token
          if [ ${#SEMGREP_APP_TOKEN} -lt 20 ]; then
            echo "SEMGREP_APP_TOKEN appears too short to be valid" >&2
            exit 1
          fi
          # Try to access the API - note: many endpoints require Team/Enterprise tier
          # Agent/CI tokens may not work with Web API endpoints
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${SEMGREP_APP_TOKEN}" \
            https://semgrep.dev/api/v1/orgs)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Semgrep API status: ${status}"
          # Accept 200 (success), 401 means token format is valid but unauthorized
          # 404 means endpoint not available for this token type
          if [ "${status}" = "200" ]; then
            echo "✓ Semgrep API token is valid (authenticated successfully)"
          elif [ "${status}" = "401" ]; then
            echo "⚠ Semgrep token format valid but unauthorized - may need Web API scope"
            echo "Note: This is expected for Agent/CI scoped tokens"
          elif [ "${status}" = "404" ]; then
            echo "⚠ Semgrep API endpoint not found - token may have limited scope"
            echo "Note: Agent/CI tokens may not access all Web API endpoints"
          else
            echo "Response: ${body}" >&2
            echo "Semgrep healthcheck returned unexpected status ${status}" >&2
            exit 1
          fi

      - name: FOSSA - CLI attribution endpoint
        env:
          FOSSA_API_KEY: ${{ secrets.FOSSA_API_KEY }}
        run: |
          if [ -z "${FOSSA_API_KEY}" ]; then
            echo "FOSSA_API_KEY not set; skipping FOSSA healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Use CLI-compatible endpoint that works with push-only tokens
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: token ${FOSSA_API_KEY}" \
            "https://app.fossa.com/api/cli/organization")
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "FOSSA organization status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "FOSSA healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ FOSSA API key is valid"

      # ============================================================
      # Communication & Deployment Secrets
      # ============================================================
      - name: SSH - connection test
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          if [ -z "${SSH_HOST}" ] || [ -z "${SSH_USER}" ] || [ -z "${SSH_PRIVATE_KEY}" ]; then
            echo "SSH secrets not fully set; skipping SSH healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Setup SSH key
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          printf '%s' "${SSH_PRIVATE_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # Add host to known_hosts
          ssh-keyscan -H "${SSH_HOST}" >> ~/.ssh/known_hosts 2>/dev/null || true
          # Test SSH connection with a simple command
          if ssh -o ConnectTimeout=10 -o BatchMode=yes "${SSH_USER}@${SSH_HOST}" echo "SSH connection successful"; then
            echo "✓ SSH connection to ${SSH_HOST} is working"
          else
            echo "SSH connection test failed" >&2
            exit 1
          fi
          # Cleanup
          rm -f ~/.ssh/id_rsa

      - name: Gmail SMTP - authentication test
        env:
          GMAIL_SMTP_USERNAME: ${{ secrets.GMAIL_SMTP_USERNAME }}
          GMAIL_SMTP_CREDENTIALS: ${{ secrets.GMAIL_SMTP_CREDENTIALS }}
        run: |
          if [ -z "${GMAIL_SMTP_USERNAME}" ] || [ -z "${GMAIL_SMTP_CREDENTIALS}" ]; then
            echo "Gmail SMTP secrets not fully set; skipping Gmail SMTP healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Test SMTP authentication using curl
          # This sends EHLO and AUTH commands without actually sending an email
          response=$(curl -v --ssl-reqd \
            --url "smtps://smtp.gmail.com:465" \
            --user "${GMAIL_SMTP_USERNAME}:${GMAIL_SMTP_CREDENTIALS}" \
            --mail-from "${GMAIL_SMTP_USERNAME}" \
            --mail-rcpt "${GMAIL_SMTP_USERNAME}" \
            -T /dev/null 2>&1 || true)
          # Check if authentication succeeded (look for 235 auth success)
          if echo "$response" | grep -q "235"; then
            echo "✓ Gmail SMTP authentication successful"
          elif echo "$response" | grep -q "Authentication successful"; then
            echo "✓ Gmail SMTP authentication successful"
          elif echo "$response" | grep -qi "535\|534\|530"; then
            echo "Gmail SMTP authentication failed" >&2
            echo "Response excerpt: $(echo "$response" | grep -i -E '53[0-5]' | head -3)" >&2
            exit 1
          else
            # If we get here without auth errors, credentials are likely valid
            echo "✓ Gmail SMTP credentials appear valid (no auth errors)"
          fi

      - name: SOPS AGE key - format validation
        env:
          SOPS_AGE_KEY: ${{ secrets.SOPS_AGE_KEY }}
        run: |
          if [ -z "${SOPS_AGE_KEY}" ]; then
            echo "SOPS_AGE_KEY not set; skipping SOPS healthcheck"
            exit 0
          fi
          set -euo pipefail
          # AGE secret keys start with AGE-SECRET-KEY-1
          if echo "${SOPS_AGE_KEY}" | grep -q "^AGE-SECRET-KEY-1"; then
            echo "✓ SOPS_AGE_KEY has valid AGE secret key format"
          else
            echo "SOPS_AGE_KEY does not appear to be a valid AGE secret key" >&2
            echo "Expected format: AGE-SECRET-KEY-1..." >&2
            exit 1
          fi

      - name: Let's Encrypt email - format validation
        env:
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
        run: |
          if [ -z "${LETSENCRYPT_EMAIL}" ]; then
            echo "LETSENCRYPT_EMAIL not set; skipping validation"
            exit 0
          fi
          set -euo pipefail
          # Basic email format validation
          if echo "${LETSENCRYPT_EMAIL}" | grep -qE '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'; then
            echo "✓ LETSENCRYPT_EMAIL has valid email format"
          else
            echo "LETSENCRYPT_EMAIL does not appear to be a valid email address" >&2
            exit 1
          fi
