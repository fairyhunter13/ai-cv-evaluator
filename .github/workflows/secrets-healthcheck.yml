name: Secrets Healthcheck

on:
  workflow_dispatch:
  schedule:
    - cron: "0 1 * * *" # 01:00 UTC daily
  push:
    branches: [ main ]

concurrency:
  group: secrets-healthcheck-${{ github.ref }}
  cancel-in-progress: true

jobs:
  healthcheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      # ============================================================
      # AI Provider API Keys
      # ============================================================
      - name: Groq account 1 - models endpoint
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        run: |
          if [ -z "${GROQ_API_KEY}" ]; then
            echo "GROQ_API_KEY not set; skipping Groq account 1 healthcheck"
            exit 0
          fi
          set -euo pipefail
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${GROQ_API_KEY}" \
            https://api.groq.com/openai/v1/models)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Groq account 1 /models status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "Groq account 1 healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ Groq account 1 API key is valid"

      - name: Groq account 2 - models endpoint
        env:
          GROQ_API_KEY_2: ${{ secrets.GROQ_API_KEY_2 }}
        run: |
          if [ -z "${GROQ_API_KEY_2}" ]; then
            echo "GROQ_API_KEY_2 not set; skipping Groq account 2 healthcheck"
            exit 0
          fi
          set -euo pipefail
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${GROQ_API_KEY_2}" \
            https://api.groq.com/openai/v1/models)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Groq account 2 /models status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "Groq account 2 healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ Groq account 2 API key is valid"

      - name: OpenRouter account 1 - auth/key endpoint
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          if [ -z "${OPENROUTER_API_KEY}" ]; then
            echo "OPENROUTER_API_KEY not set; skipping OpenRouter account 1 healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Use /api/v1/auth/key to validate the key itself (requires auth)
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${OPENROUTER_API_KEY}" \
            https://openrouter.ai/api/v1/auth/key)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "OpenRouter account 1 /auth/key status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "OpenRouter account 1 healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ OpenRouter account 1 API key is valid"

      - name: OpenRouter account 2 - auth/key endpoint
        env:
          OPENROUTER_API_KEY_2: ${{ secrets.OPENROUTER_API_KEY_2 }}
        run: |
          if [ -z "${OPENROUTER_API_KEY_2}" ]; then
            echo "OPENROUTER_API_KEY_2 not set; skipping OpenRouter account 2 healthcheck"
            exit 0
          fi
          set -euo pipefail
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${OPENROUTER_API_KEY_2}" \
            https://openrouter.ai/api/v1/auth/key)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "OpenRouter account 2 /auth/key status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "OpenRouter account 2 healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ OpenRouter account 2 API key is valid"

      - name: OpenAI - models endpoint
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          if [ -z "${OPENAI_API_KEY}" ]; then
            echo "OPENAI_API_KEY not set; skipping OpenAI healthcheck"
            exit 0
          fi
          set -euo pipefail
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            https://api.openai.com/v1/models)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "OpenAI /models status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "OpenAI healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ OpenAI API key is valid"

      # ============================================================
      # Infrastructure & DevOps Secrets
      # ============================================================

      - name: Cloudflare - token verify endpoint
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          if [ -z "${CLOUDFLARE_API_TOKEN}" ]; then
            echo "CLOUDFLARE_API_TOKEN not set; skipping Cloudflare healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Use the official token verify endpoint
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            https://api.cloudflare.com/client/v4/user/tokens/verify)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Cloudflare token verify status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "Cloudflare healthcheck failed with status ${status}" >&2
            exit 1
          fi
          # Check if token status is active
          token_status=$(echo "$body" | jq -r '.result.status // empty')
          if [ "${token_status}" != "active" ]; then
            echo "Cloudflare token is not active: ${token_status}" >&2
            exit 1
          fi
          echo "✓ Cloudflare API token is valid and active"

      - name: Cloudflare - zone access verification
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          if [ -z "${CLOUDFLARE_API_TOKEN}" ] || [ -z "${CLOUDFLARE_ZONE_ID}" ]; then
            echo "Cloudflare zone secrets not fully set; skipping zone access check"
            exit 0
          fi
          set -euo pipefail
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}")
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Cloudflare zone access status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "Cloudflare zone access check failed with status ${status}" >&2
            exit 1
          fi
          # Optionally verify that the zone is attached to the expected account
          if [ -n "${CLOUDFLARE_ACCOUNT_ID}" ]; then
            actual_account_id=$(echo "$body" | jq -r '.result.account.id // empty')
            if [ -z "${actual_account_id}" ]; then
              echo "Cloudflare zone response missing account.id; cannot verify CLOUDFLARE_ACCOUNT_ID" >&2
              exit 1
            fi
            if [ "${actual_account_id}" != "${CLOUDFLARE_ACCOUNT_ID}" ]; then
              echo "Cloudflare account ID mismatch for configured zone" >&2
              exit 1
            fi
            echo "✓ Cloudflare account ID matches zone account (ID not logged)"
          fi
          echo "✓ Cloudflare zone access verified"

      # ============================================================
      # Security & Compliance Tools
      # ============================================================
      - name: Snyk - REST API self endpoint
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          if [ -z "${SNYK_TOKEN}" ]; then
            echo "SNYK_TOKEN not set; skipping Snyk healthcheck"
            exit 0
          fi
          set -euo pipefail
          # REST API requires Content-Type header
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: token ${SNYK_TOKEN}" \
            -H "Content-Type: application/vnd.api+json" \
            "https://api.snyk.io/rest/self?version=2024-10-15")
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Snyk REST /self status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "Snyk healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ Snyk API token is valid"

      - name: Semgrep - token format validation
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
        run: |
          if [ -z "${SEMGREP_APP_TOKEN}" ]; then
            echo "SEMGREP_APP_TOKEN not set; skipping Semgrep healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Semgrep tokens are typically long alphanumeric strings
          # Format check: should be non-empty and look like a valid token
          if [ ${#SEMGREP_APP_TOKEN} -lt 20 ]; then
            echo "SEMGREP_APP_TOKEN appears too short to be valid" >&2
            exit 1
          fi
          # Try to access the API - note: many endpoints require Team/Enterprise tier
          # Agent/CI tokens may not work with Web API endpoints
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${SEMGREP_APP_TOKEN}" \
            https://semgrep.dev/api/v1/orgs)
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "Semgrep API status: ${status}"
          # Accept 200 (success), 401 means token format is valid but unauthorized
          # 404 means endpoint not available for this token type
          if [ "${status}" = "200" ]; then
            echo "✓ Semgrep API token is valid (authenticated successfully)"
          elif [ "${status}" = "401" ]; then
            echo "⚠ Semgrep token format valid but unauthorized - may need Web API scope"
            echo "Note: This is expected for Agent/CI scoped tokens"
          elif [ "${status}" = "404" ]; then
            echo "⚠ Semgrep API endpoint not found - token may have limited scope"
            echo "Note: Agent/CI tokens may not access all Web API endpoints"
          else
            echo "Response: ${body}" >&2
            echo "Semgrep healthcheck returned unexpected status ${status}" >&2
            exit 1
          fi

      - name: FOSSA - CLI attribution endpoint
        env:
          FOSSA_API_KEY: ${{ secrets.FOSSA_API_KEY }}
        run: |
          if [ -z "${FOSSA_API_KEY}" ]; then
            echo "FOSSA_API_KEY not set; skipping FOSSA healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Use CLI-compatible endpoint that works with push-only tokens
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: token ${FOSSA_API_KEY}" \
            "https://app.fossa.com/api/cli/organization")
          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "FOSSA organization status: ${status}"
          if [ "${status}" != "200" ]; then
            echo "Response: ${body}" >&2
            echo "FOSSA healthcheck failed with status ${status}" >&2
            exit 1
          fi
          echo "✓ FOSSA API key is valid"

      - name: Codecov - token format validation
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
        run: |
          if [ -z "${CODECOV_TOKEN}" ]; then
            echo "CODECOV_TOKEN not set; skipping Codecov healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Basic sanity check: Codecov tokens are long random strings; check length only.
          if [ ${#CODECOV_TOKEN} -lt 30 ]; then
            echo "CODECOV_TOKEN appears too short to be valid" >&2
            exit 1
          fi
          echo "✓ CODECOV_TOKEN format looks valid (full validation occurs via CI upload)"

      # ============================================================
      # Communication & Deployment Secrets
      # ============================================================
      - name: SSH - connection test
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          if [ -z "${SSH_HOST}" ] || [ -z "${SSH_USER}" ] || [ -z "${SSH_PRIVATE_KEY}" ]; then
            echo "SSH secrets not fully set; skipping SSH healthcheck"
            exit 0
          fi
          set -euo pipefail
          # Setup SSH key
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          printf '%s' "${SSH_PRIVATE_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # Add host to known_hosts
          ssh-keyscan -H "${SSH_HOST}" >> ~/.ssh/known_hosts 2>/dev/null || true
          # Test SSH connection with a simple command
          if ssh -o ConnectTimeout=10 -o BatchMode=yes "${SSH_USER}@${SSH_HOST}" echo "SSH connection successful"; then
            echo "✓ SSH connection to ${SSH_HOST} is working"
          else
            echo "SSH connection test failed" >&2
            exit 1
          fi
          # Cleanup
          rm -f ~/.ssh/id_rsa

      - name: SOPS AGE key - format validation
        env:
          SOPS_AGE_KEY: ${{ secrets.SOPS_AGE_KEY }}
        run: |
          if [ -z "${SOPS_AGE_KEY}" ]; then
            echo "SOPS_AGE_KEY not set; skipping SOPS healthcheck"
            exit 0
          fi
          set -euo pipefail
          # AGE secret keys start with AGE-SECRET-KEY-1
          if echo "${SOPS_AGE_KEY}" | grep -q "^AGE-SECRET-KEY-1"; then
            echo "✓ SOPS_AGE_KEY has valid AGE secret key format"
          else
            echo "SOPS_AGE_KEY does not appear to be a valid AGE secret key" >&2
            echo "Expected format: AGE-SECRET-KEY-1..." >&2
            exit 1
          fi

      - name: Let's Encrypt email - format validation
        env:
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
        run: |
          if [ -z "${LETSENCRYPT_EMAIL}" ]; then
            echo "LETSENCRYPT_EMAIL not set; skipping validation"
            exit 0
          fi
          set -euo pipefail
          # Basic email format validation
          if echo "${LETSENCRYPT_EMAIL}" | grep -qE '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'; then
            echo "✓ LETSENCRYPT_EMAIL has valid email format"
          else
            echo "LETSENCRYPT_EMAIL does not appear to be a valid email address" >&2
            exit 1
          fi
